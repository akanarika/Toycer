// ---- Util ----
const float Pi = 3.14159265359;
float remap01(float a, float b, float t) { return (t - a) / (b - a);}
float eps = 0.0001; // epsilon
vec4 bg_color = vec4(.9, .8, .6, 1.);

// ---- Material ----
struct Material {
    vec3 dif;
    vec3 spec;
};
    
Material makeMaterial(in vec3 d, in vec3 s) { Material m; m.dif = d; m.spec = s; return m;}

// ---- Ray ----
struct Ray {
	vec3 o;
    vec3 d;
    float tmin;
    float tmax;
};
    
struct Hit {
    bool did;
    vec3 p;
    vec3 n;
    float t;
    Material m;
};
    
Ray makeRay(in vec3 o, in vec3 d) { Ray r; r.o = o; r.d = d; r.tmin = 0.; r.tmax = 1000000000.; return r;}

// ---- Geometry ----
struct Sphere {
    vec3 o;
    float r;
    Material m;
};

Sphere makeSphere(in vec3 o, in float r, Material m) { Sphere s; s.o = o; s.r = r; s.m = m; return s;}  
    
bool intersectSphere(Sphere s, Ray r, inout Hit hit) {
    float a = dot(r.d, r.d);
    float b = 2. * dot(r.o - s.o, r.d);
    float c = dot(r.o - s.o, r.o - s.o) - s.r * s.r;
    float delta = b * b - 4. * a * c;
    if (delta < 0.) return false;
    float t = (-b - sqrt(delta)) / (2. * a);
    if (t > r.tmin && t < r.tmax) {
        hit.did = true;
        hit.t = t;
        hit.p = r.o + r.d * hit.t;
        hit.n = normalize(hit.p - s.o);
        hit.m = s.m;
        return true;
    }
    return false;
}

bool intersectScene(Ray r, inout Hit hit) {
    // Sphere
    Sphere s1 = makeSphere(vec3(-.6 * sin(iTime) + 1.5, .2, -5. - .6 * cos(iTime)), .5, 
                           makeMaterial(vec3(.9, .8, .5), vec3(.9)));
    Sphere s2 = makeSphere(vec3(.5 * sin(iTime) - 1., .5, -5. +.5 * cos(iTime)), .8, 
                           makeMaterial(vec3(.8, .5, .9), vec3(.6)));
    Sphere s3 = makeSphere(vec3(1., -30., -10.), 30., 
                           makeMaterial(vec3(.4), vec3(.1)));
    Sphere s[3] = Sphere[3](s1, s2, s3);
    bool didHit = false;
    for (int i = 0; i < 3; i++) {
    	if (intersectSphere(s[i], r, hit)) {
            r.tmax = hit.t;
        	didHit = true;
    	}
    }
    return didHit;
}

vec4 color(Ray r, inout Hit hit) {
    // Light direction
    vec3 light = normalize(vec3(5., 8., 10.));
    
    vec4 col;
    if (intersectScene(r, hit)) {
        vec3 l = light;
        float dif = max(0., dot(l, hit.n));
        vec3 h = (l - r.d) / 2.; 
        float spc = pow(max(0., dot(h, hit.n)), 32.);
        
        // Shadow test ray
        Ray str = makeRay(hit.p + eps * l, l);
        Hit sth;
        if (!intersectScene(str, sth)) {
            col += 2. * vec4(hit.m.dif, 1.)  // diffuse color
                    * dif
                   + 10. * vec4(hit.m.spec, 1.)  // spec color
                    * spc
                   + .02 * vec4(hit.m.dif, 1.);  // ambient color**/
            return col;
        }
    }
    return col;
}

vec4 calcColor(Ray r) {
    Ray nr = r;
    float fac = 1.;
    vec4 col = bg_color;
    for (int i = 0; i < 5; i++) {
        Hit hit;
        vec4 att = color(nr, hit);
        if (!hit.did) {
            return col;
        } else {
            nr.d = normalize(reflect(nr.d, hit.n));
            nr.o = hit.p + eps * nr.d;
            col *= att;
        }
    }
    return vec4(0.);
}

void shootRays(vec3 ro, vec3 rd, out vec4 col) {
    float unit_x = 1. / iResolution.x;
    float unit_y = 1. / iResolution.y;
    // 4 samples
    vec2 offset[4] = vec2[4](vec2(-unit_x / 2., -unit_y / 2.), vec2(-unit_x / 2., unit_y / 2.),
                             vec2(unit_x / 2., -unit_y / 2.), vec2(unit_x / 2., unit_y / 2.));
    vec4 total;
    for (int i = 0; i < 4; i++) {
        vec2 off = offset[i];
        Ray r = makeRay(ro - vec3(off, 0.), normalize(rd));
        total += calcColor(r);
    }
	col = total / 4.;
}

// ---- main ----
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    // Normalized pixel coordinates (y from 0 to 1)
    vec2 uv = fragCoord / iResolution.xy;
    // y from -.5 to .5
    uv -= 0.5;
    // x from -.5 * ratio to .5 * ratio
    uv.x *= iResolution.x / iResolution.y;
    
    // Mouse
    vec2 m = iMouse.xy / iResolution.xy;
    
    // Ray
    vec3 ro = vec3(0., 0., 2.);
    vec3 rd = vec3(uv, 0.) - ro;
    
    // Output to screen
    vec4 col;
    shootRays(ro, rd, col);
    fragColor = col;
}

